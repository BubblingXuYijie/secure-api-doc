# Digital Signature Verification

## Introduction

Digital signatures play a crucial role in the field of information security, and their main functions include but are not limited to the following aspects:
- Data integrity: Digital signatures can ensure that information is not tampered with during transmission. If the data received by the recipient is inconsistent with the data sent by the sender (for example, if it is modified by a third party during transmission), the digital signature verification will fail, thereby alerting the recipient that the integrity of the data has been compromised.
- Identity verification: Digital signatures can be used to verify that a message really comes from the claimed sender. Because only someone who has the correct private key can generate a valid digital signature, the existence and validity of the signature can serve as a proof of the sender's identity.
- Non-repudiation: Once someone signs a message with their private key, they cannot deny this action. This is because no one else can generate the correct signature except the owner of the private key. This provides legal evidence for transactions, contracts, etc.
- Prevent replay attacks: By including a timestamp or other unique identifier in the signature, digital signatures can help prevent replay attacks, where attackers repeat sending intercepted information in an attempt to generate unauthorized effects.
- Enhance trust: In e-commerce and other online transactions, digital signatures increase the trust between the two parties. Buyers and sellers can confirm each other's identities through digital signatures, and ensure that the transaction terms will not be tampered with.

## Usage

1. In the configuration, you can enable digital signature verification in the backend, and you don't need to configure a digital signature key. It will be automatically generated and printed in the console.

2. The front-end uses the digital signature private key generated in step 1 to sign the data sent to the interface, and carries it in the "X-signature" in the request header (when generating the signature, pay attention to whether the backend has enabled the "isUrlSafe" configuration. If it is enabled, the signature generated by the front-end must be url safe).

3. Back-end components will automatically verify the signature of 'X-signature' using the public key.

4. When the back-end returns data to the front-end, it will automatically add a response header `X-signature`, including the signature of the return value (remember to allow this response header in the code or nginx when crossing domains).

Of course, classes for generating signatures for data are also provided. You can use: Inject `rsaSignatureUtils` and call the `rsaSignatureutils.sign(byte[] data)` method to generate a signature for the data. `rsaSignatureUtils.verify(byte[] data, String signature)` can verify data






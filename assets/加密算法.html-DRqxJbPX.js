import{_ as o,c,a as i,o as d}from"./app-CXRzL9wg.js";const l={};function _(t,e){return d(),c("div",null,[...e[0]||(e[0]=[i('<h1 id="加密算法" tabindex="-1"><a class="header-anchor" href="#加密算法"><span>加密算法</span></a></h1><blockquote><p>SecureApi 提供了 15 种加密算法，在 <code>CipherAlgorithmEnum</code> 枚举类中存储</p></blockquote><ul><li><code>AES_CBC_NO_PADDING</code></li><li><code>AES_CBC_PKCS5</code></li><li><code>AES_ECB_NO_PADDING</code></li><li><code>AES_ECB_PKCS5</code></li><li><code>DES_CBC_NO_PADDING</code></li><li><code>DES_CBC_PKCS5</code></li><li><code>DES_ECB_NO_PADDING</code></li><li><code>DES_ECB_PKCS5</code></li><li><code>DES_EDE_CBC_NO_PADDING</code></li><li><code>DES_EDE_CBC_PKCS5</code></li><li><code>DES_EDE_ECB_NO_PADDING</code></li><li><code>DES_EDE_ECB_PKCS5</code></li><li><code>RSA_ECB_PKCS1</code></li><li><code>RSA_ECB_SHA1</code></li><li><code>RSA_ECB_SHA256</code></li></ul><blockquote><p>带<code>CBC</code> 字样的算法加解密都需要同时使用 key 和 iv，<code>ECB</code> 只需要 key，每种算法要求的 key 和 iv 字符数组长度不一样，建议使用下个章节介绍的 <a href="CipherUtils">CipherUtils</a> 来生成 key 和 iv</p></blockquote><blockquote><p>带<code>NO_PADDING</code> 字样的算法，都需要自行填充明文字符数组长度为16的整倍数，解密后自行去除填充的字符才能得到原字符串，不建议使用</p></blockquote><blockquote><p>除了 <code>RSA</code> 开头的是非对称加密，其余都是对称加密，安全性：<code>RSA</code> &gt; <code>AES</code> &gt; <code>DES_EDE</code> &gt; <code>DES</code></p></blockquote>',6)])])}const a=o(l,[["render",_]]),C=JSON.parse('{"path":"/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html","title":"加密算法","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1719421325000,"contributors":[{"name":"XuYijie","username":"XuYijie","email":"1119461672@qq.com","commits":1,"url":"https://github.com/XuYijie"}],"changelog":[{"hash":"c8e552f5118f279b29ddf5805df91a53e16d2e78","time":1719421325000,"email":"1119461672@qq.com","author":"XuYijie","message":"完善文档"}]},"filePathRelative":"加密算法.md"}');export{a as comp,C as data};
